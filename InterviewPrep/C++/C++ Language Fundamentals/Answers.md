1. A pointer is a variable that holds the memory address of another variable. Pointers can be set to the value of nullptr. This is denoted by "*" syntax. While a reference is an alias for another variable. A reference is giving a variable a different name. Both variables would be the same location in memory. Reference can only be assigned one time and can not be changed after it is set. This is denoted by "&" syntax. References are used when you do not want to make a copy of something.
2. Smart pointers work similar to the traditional functionality of creating a destroying pointers with new and free. The difference is here is that smart pointers will destroy themselves when no longer referenced in scope. So if a shared_ptr is creating in a function, once the function has completed and the shared_ptr was not shared and referenced externally, the memory location will be freed. Shared_ptr can also be referenced by many and would keep alive until all references are out of scope while unique_ptr is freed when this reference goes out of scope.  *Shared pointers have a reference count of who has access and will continue to be active until the last owner goes out of scope, while Unique pointers can not be copied and is deleted when the object goes out a scope.* Unique pointers can still be moved using std::move. Use Unique pointers when you want a single owner of a resource. Use shared pointers when multiple parts of a program will have access to the resource. Weak pointer is a subset of shared_ptr but is not considered an owning reference, thus is not considered to keep the resource from being deleted.
3. RAII is a programming idiom where a resource is allocated during object creation and a resource is deallocated when the object is destroyed. RAII tied the lifecycle of a resource to the lifecycle of the object, thus when the object goes out of scope the resource is released. This is important to prevent resource leaks and managing memory effectively. The constructor and deconstructor is needed due to this effect.
4. A binary search tree is a data structure that is provided by a pointer to the head node. Each node will have the value it represents and a left and a right node. Every node that is to the left of current node will be less than the current node and every node to the right of the current node is greater than the current node. Depending on the implementation nodes that are equal to could be to the left or right. 
5. A shallow copy is a bitwise copy of the object but does not copy or dynamically create new copies of any nested objects. The original and copy's nest objects would still be pointing to the same. While a deep copy would copy all nested objects and allocate the memory so the objects are completely different.